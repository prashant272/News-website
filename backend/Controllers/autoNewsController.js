const { scrapeNews, getLatestLinks } = require("../Services/scraperService");
const generateArticle = require("../Services/aiService");
const NewsConfig = require("../Models/news.model");
const newsSources = require("../Config/newsSources");

// Helper to create slug
const createSlug = (title) => {
    return title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/(^-|-$)+/g, "");
};

// 1. Manual Single URL Processing
const autoGenerateNews = async (req, res) => {
    try {
        const { url, category } = req.body;

        if (!url || !category) {
            return res.status(400).json({
                success: false,
                msg: "URL and Category are required."
            });
        }

        const scraped = await scrapeNews(url);
        const aiContent = await generateArticle(scraped.facts);
        const slug = createSlug(scraped.title);

        const newPost = {
            title: scraped.title,
            slug: slug,
            category: category,
            content: aiContent,
            source: scraped.source,
            autoGenerated: true,
            status: "draft",
            author: "AI Writer",
            isLatest: false,
            isTrending: false,
            isHidden: true
        };

        let newsConfig = await NewsConfig.findOne({ isActive: true });
        if (!newsConfig) newsConfig = new NewsConfig({ isActive: true });

        if (!newsConfig[category]) {
            return res.status(400).json({ success: false, msg: `Invalid category: ${category}` });
        }

        const duplicate = newsConfig[category].find(item => item.slug === slug);
        if (duplicate) {
            return res.status(409).json({ success: false, msg: "News article already exists.", slug: slug });
        }

        newsConfig[category].unshift(newPost);
        newsConfig.lastUpdated = new Date();
        await newsConfig.save();

        res.json({ success: true, msg: "News auto-generated.", post: newPost });

    } catch (error) {
        console.error("Auto-News Error:", error);
        res.status(500).json({ error: error.message });
    }
};

// 2. Batch Processing for RSS Feeds
const fetchAndProcessNews = async (req, res) => {
    try {
        let stats = {
            processed: 0,
            duplicates: 0,
            errors: 0,
            articles: []
        };

        const newsConfig = await NewsConfig.findOne({ isActive: true }) || new NewsConfig({ isActive: true });

        // Iterate through all sources
        for (const source of newsSources) {
            console.log(`Checking Source: ${source.name}...`);

            // 1. Get latest links from RSS
            const items = await getLatestLinks(source.url);

            for (const item of items) {
                const slug = createSlug(item.title);
                const category = source.category;

                // 2. Check for Duplicates in DB
                if (newsConfig[category]) {
                    const isDuplicate = newsConfig[category].some(existing => existing.slug === slug);
                    if (isDuplicate) {
                        console.log(`Skipping Duplicate: ${item.title}`);
                        stats.duplicates++;
                        continue;
                    }
                }

                // 3. Process New Article
                try {
                    console.log(`Scraping: ${item.title}`);
                    const scraped = await scrapeNews(item.link);

                    console.log(`Generating AI Content...`);
                    const aiContent = await generateArticle(scraped.facts);

                    const newPost = {
                        title: scraped.title,
                        slug: slug,
                        category: category,
                        content: aiContent,
                        source: source.name,  // Use Source Name instead of URL for cleaner display
                        targetLink: item.link, // Keep original link
                        autoGenerated: true,
                        status: "draft",
                        author: "AI News Bot",
                        isLatest: false,
                        isTrending: false,
                        isHidden: true
                    };

                    newsConfig[category].unshift(newPost);
                    stats.processed++;
                    stats.articles.push(item.title);

                    // Add a small delay to avoid hitting OpenAI rate limits too hard
                    await new Promise(resolve => setTimeout(resolve, 2000));

                } catch (err) {
                    console.error(`Failed to process ${item.link}:`, err.message);
                    stats.errors++;
                }
            }
        }

        if (stats.processed > 0) {
            newsConfig.lastUpdated = new Date();
            await newsConfig.save();
        }

        res.json({
            success: true,
            msg: "Batch processing completed.",
            stats
        });

    } catch (error) {
        console.error("Batch Process Error:", error);
        res.status(500).json({ error: "Batch processing failed." });
    }
};

// 3. Get All AI Drafts
const getAutoGeneratedDrafts = async (req, res) => {
    console.log("ðŸ‘‰ /auto-news/drafts HIT! Fetching config...");
    try {
        const newsConfig = await NewsConfig.findOne({ isActive: true }).lean();
        console.log("Config Result:", newsConfig ? "Found" : "Not Found");

        if (!newsConfig) {
            return res.status(404).json({ success: false, msg: "Config not found" });
        }

        let allDrafts = [];
        const categories = ["india", "sports", "business", "technology", "entertainment", "lifestyle", "world", "health"];

        categories.forEach(cat => {
            if (newsConfig[cat]) {
                const drafts = newsConfig[cat]
                    .filter(item => item.autoGenerated === true && item.status === 'draft')
                    .map(item => ({ ...item, category: cat })); // Add category to item for display
                allDrafts = [...allDrafts, ...drafts];
            }
        });

        // Sort by newest first (assuming internal _id or we can use generic sort if timestamp wasn't in subdoc)
        // Note: Subdocs might not have createdAt unless defined in schema, but we can reverse since we unshift

        res.json({
            success: true,
            count: allDrafts.length,
            drafts: allDrafts
        });

    } catch (error) {
        console.error("Get Drafts Error:", error);
        res.status(500).json({ error: "Failed to fetch drafts." });
    }
};

module.exports = { autoGenerateNews, fetchAndProcessNews, getAutoGeneratedDrafts };

